// Code generated by bpf2go; DO NOT EDIT.
//go:build (mips || mips64 || ppc64 || s390x) && linux

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type hellobufferconfigUserMsgT struct {
	_       structs.HostLayout
	Message [12]int8
}

// loadHellobufferconfig returns the embedded CollectionSpec for hellobufferconfig.
func loadHellobufferconfig() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_HellobufferconfigBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load hellobufferconfig: %w", err)
	}

	return spec, err
}

// loadHellobufferconfigObjects loads hellobufferconfig and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*hellobufferconfigObjects
//	*hellobufferconfigPrograms
//	*hellobufferconfigMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadHellobufferconfigObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadHellobufferconfig()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// hellobufferconfigSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hellobufferconfigSpecs struct {
	hellobufferconfigProgramSpecs
	hellobufferconfigMapSpecs
	hellobufferconfigVariableSpecs
}

// hellobufferconfigProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hellobufferconfigProgramSpecs struct {
	Hello *ebpf.ProgramSpec `ebpf:"hello"`
}

// hellobufferconfigMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hellobufferconfigMapSpecs struct {
	Output     *ebpf.MapSpec `ebpf:"output"`
	UserConfig *ebpf.MapSpec `ebpf:"user_config"`
}

// hellobufferconfigVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hellobufferconfigVariableSpecs struct {
}

// hellobufferconfigObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadHellobufferconfigObjects or ebpf.CollectionSpec.LoadAndAssign.
type hellobufferconfigObjects struct {
	hellobufferconfigPrograms
	hellobufferconfigMaps
	hellobufferconfigVariables
}

func (o *hellobufferconfigObjects) Close() error {
	return _HellobufferconfigClose(
		&o.hellobufferconfigPrograms,
		&o.hellobufferconfigMaps,
	)
}

// hellobufferconfigMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadHellobufferconfigObjects or ebpf.CollectionSpec.LoadAndAssign.
type hellobufferconfigMaps struct {
	Output     *ebpf.Map `ebpf:"output"`
	UserConfig *ebpf.Map `ebpf:"user_config"`
}

func (m *hellobufferconfigMaps) Close() error {
	return _HellobufferconfigClose(
		m.Output,
		m.UserConfig,
	)
}

// hellobufferconfigVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadHellobufferconfigObjects or ebpf.CollectionSpec.LoadAndAssign.
type hellobufferconfigVariables struct {
}

// hellobufferconfigPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadHellobufferconfigObjects or ebpf.CollectionSpec.LoadAndAssign.
type hellobufferconfigPrograms struct {
	Hello *ebpf.Program `ebpf:"hello"`
}

func (p *hellobufferconfigPrograms) Close() error {
	return _HellobufferconfigClose(
		p.Hello,
	)
}

func _HellobufferconfigClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed hellobufferconfig_bpfeb.o
var _HellobufferconfigBytes []byte
